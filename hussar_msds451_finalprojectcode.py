# -*- coding: utf-8 -*-
"""Hussar_MSDS451_FinalProjectCode.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kuOYYesIAss_T2Zp4_y7QTH6E6yid-BR
"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# set random seed
np.random.seed(42)

# portfolio composition
portfolio = {
    'AMZN': 0.15, # amazon
    'TGT': 0.13, # target
    'COST': 0.12, # costco
    'BNED': 0.08, # barnes & noble education
    'SCHL': 0.09, # scholastic
    'PSO': 0.08, # pearson
    'NWSA': 0.10, # news corp
    'NYT': 0.10, # new york times
    'RELX': 0.08, # relx
    'TRI': 0.07 # thomson reuters
}

def fetch_stock_data(tickers, start='2015-01-01', end='2025-08-01'):
    """historical prices for all stocks"""
    prices = pd.DataFrame()

    for ticker in tickers:
        try:
            stock = yf.download(ticker, start=start, end=end, progress=False)
            if not stock.empty:
                prices[ticker] = stock['Close']
                print(f"{ticker}")
            else:
                # use spy as proxy if no data
                spy = yf.download('SPY', start=start, end=end, progress=False)
                prices[ticker] = spy['Close'] * np.random.uniform(0.8, 1.2)
                print(f"× {ticker} (using proxy)")
        except:
            # use spy as proxy if error
            spy = yf.download('SPY', start=start, end=end, progress=False)
            prices[ticker] = spy['Close'] * np.random.uniform(0.8, 1.2)
            print(f"× {ticker} (using proxy)")

    return prices.fillna(method='ffill')

def calculate_signals(prices, lookback=20):
    signals = pd.DataFrame(index=prices.index, columns=prices.columns)

    for col in prices.columns:
        # calculate indicators
        sma = prices[col].rolling(lookback).mean()
        std = prices[col].rolling(lookback).std()
        momentum = prices[col].pct_change(252)  # 1-year momentum

        # mean reversion signals
        z_score = (prices[col] - sma) / std

        # combined signals
        signals[col] = 0
        signals.loc[(z_score < -2) | (momentum > 0.2), col] = 1  # buy
        signals.loc[(z_score > 2) | (momentum < -0.1), col] = -1  # sell

    return signals.fillna(0)

def backtest_strategy(prices, signals, portfolio_weights):
    # calculate daily returns
    returns = prices.pct_change()

    # calculate strategy returns
    strategy_returns = pd.Series(index=returns.index, dtype=float)
    strategy_returns.iloc[0] = 0

    for i in range(1, len(returns)):
        daily_return = 0
        for ticker in portfolio_weights:
            if ticker in returns.columns:
                # strategy return = signal * return * weight
                position = signals[ticker].iloc[i-1]
                stock_return = returns[ticker].iloc[i]
                weight = portfolio_weights[ticker]
                daily_return += position * stock_return * weight

        strategy_returns.iloc[i] = daily_return

    # calculate cumulative returns
    cumulative = (1 + strategy_returns).cumprod()

    return strategy_returns, cumulative

def monte_carlo_simulation(returns, n_sims=1000, n_days=252):
    """monte carlo simulation"""
    print(f"\nrunning {n_sims} simulations...")

    # get statistics from historical returns
    mean_return = returns.mean()
    std_return = returns.std()

    # run simulations
    results = []

    for i in range(n_sims):
        # generate random daily returns
        daily_returns = np.random.normal(mean_return, std_return, n_days)

        # calculate final return
        total_return = np.prod(1 + daily_returns) - 1
        annual_return = (1 + total_return) ** (252/n_days) - 1
        results.append(annual_return)

        if (i + 1) % 100 == 0:
            print(f" completed {i + 1}/{n_sims}")

    return np.array(results)

def calculate_metrics(returns, risk_free_rate=0.02):
    """performance metrics"""
    # basic metrics
    annual_return = returns.mean() * 252
    annual_vol = returns.std() * np.sqrt(252)
    sharpe = (annual_return - risk_free_rate) / annual_vol if annual_vol > 0 else 0

    # calculate max drawdown
    cumulative = (1 + returns).cumprod()
    running_max = cumulative.expanding().max()
    drawdown = (cumulative - running_max) / running_max
    max_dd = drawdown.min()

    # win rate
    win_rate = (returns > 0).sum() / len(returns)

    return {
        'annual_return': annual_return,
        'volatility': annual_vol,
        'sharpe_ratio': sharpe,
        'max_drawdown': max_dd,
        'win_rate': win_rate
    }

def plot_results(cumulative_returns, mc_results):
    """visualization"""
    fig, axes = plt.subplots(2, 2, figsize=(12, 8))

    # plot 1: cumulative returns
    axes[0, 0].plot(cumulative_returns.index, cumulative_returns.values)
    axes[0, 0].set_title('cumulative returns')
    axes[0, 0].set_xlabel('date')
    axes[0, 0].set_ylabel('return')
    axes[0, 0].grid(True, alpha=0.3)

    # plot 2: monte carlo histogram
    axes[0, 1].hist(mc_results, bins=30, edgecolor='black', alpha=0.7)
    axes[0, 1].axvline(mc_results.mean(), color='red', linestyle='--', label=f'Mean: {mc_results.mean():.2%}')
    axes[0, 1].set_title('monte carlo results')
    axes[0, 1].set_xlabel('annual return')
    axes[0, 1].set_ylabel('frequency')
    axes[0, 1].legend()
    axes[0, 1].grid(True, alpha=0.3)

    # plot 3: return distribution
    positive_pct = (mc_results > 0).sum() / len(mc_results) * 100
    axes[1, 0].pie([positive_pct, 100-positive_pct],
                   labels=['profit', 'loss'],
                   colors=['green', 'red'],
                   autopct='%1.1f%%')
    axes[1, 0].set_title('win/loss distribution')

    # plot 4: statistics
    stats_text = f"""
    monte carlo statistics:
    mean return: {mc_results.mean():.2%}
    std dev: {mc_results.std():.2%}
    best case: {mc_results.max():.2%}
    worst case: {mc_results.min():.2%}
    win rate: {positive_pct:.1f}%

    5th percentile: {np.percentile(mc_results, 5):.2%}
    95th percentile: {np.percentile(mc_results, 95):.2%}
    """

    axes[1, 1].text(0.1, 0.5, stats_text, transform=axes[1, 1].transAxes,
                    fontsize=10, verticalalignment='center')
    axes[1, 1].axis('off')

    plt.tight_layout()
    plt.savefig('etf_analysis.png', dpi=150)
    plt.show()

def generate_report(metrics, mc_results, portfolio):
    report = f"""
portfolio comp.
"""
    for ticker, weight in portfolio.items():
        report += f"{ticker:<8} {weight:.1%}\n"

    report += f"""

metrics
annual return: {metrics['annual_return']:.2%}
volatility: {metrics['volatility']:.2%}
sharpe ratio: {metrics['sharpe_ratio']:.2f}
max drawdown: {metrics['max_drawdown']:.2%}
win rate: {metrics['win_rate']:.2%}

monte carlo
Simulations: {len(mc_results)}
Mean Return: {mc_results.mean():.2%}
Std Deviation: {mc_results.std():.2%}
Profit Probability: {(mc_results > 0).sum() / len(mc_results) * 100:.1f}%

5th percentile: {np.percentile(mc_results, 5):.2%}
95th percentile: {np.percentile(mc_results, 95):.2%}
"""
    return report

# main execution
def main():
    print("book etf analysis")

    # fetch data
    prices = fetch_stock_data(portfolio.keys())

    # generate signals
    signals = calculate_signals(prices)

    # run backtest
    returns, cumulative = backtest_strategy(prices, signals, portfolio)

    # calculate metrics
    metrics = calculate_metrics(returns)

    # run monte carlo
    mc_results = monte_carlo_simulation(returns, n_sims=1000)

    # create plots
    plot_results(cumulative, mc_results)

    # generate report
    report = generate_report(metrics, mc_results, portfolio)

    # save report
    with open('performance_report.txt', 'w') as f:
        f.write(report)

    # print summary
    print("summary")
    print(f"annual return: {metrics['annual_return']:.2%}")
    print(f"sharpe ratio: {metrics['sharpe_ratio']:.2f}")
    print(f"max drawdown: {metrics['max_drawdown']:.2%}")
    print(f"win rate: {metrics['win_rate']:.1%}")
    print(f"monte carlo mean: {mc_results.mean():.2%}")
    print(f"profit probability: {(mc_results > 0).sum() / len(mc_results) * 100:.1f}%")

    return prices, signals, returns, cumulative, metrics, mc_results

if __name__ == "__main__":
    # run analysis
    results = main()